-- Generate an extremely complex auth key
local function generateSecureKey()
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?"
    local key = ""
    
    -- Part 1: Random characters (100+ chars)
    for i = 1, 150 do
        local randomIndex = math.random(1, #chars)
        key = key .. chars:sub(randomIndex, randomIndex)
    end
    
    -- Part 2: User-specific data
    key = key .. "_USER_" .. game.Players.LocalPlayer.UserId
    
    -- Part 3: Timestamp
    key = key .. "_TIME_" .. tostring(tick())
    
    -- Part 4: More random junk
    for i = 1, 100 do
        local randomIndex = math.random(1, #chars)
        key = key .. chars:sub(randomIndex, randomIndex)
    end
    
    -- Part 5: Job ID (unique per server)
    key = key .. "_JOB_" .. game.JobId
    
    -- Part 6: Even MORE random
    for i = 1, 150 do
        local randomIndex = math.random(1, #chars)
        key = key .. chars:sub(randomIndex, randomIndex)
    end
    
    return key
end

local MASTER_AUTH_KEY = generateSecureKey()

-- Create multiple layers of auth
getgenv()._XASON_MASTER_AUTH_KEY_DO_NOT_TOUCH = MASTER_AUTH_KEY
getgenv()._XASON_LOADER_ACTIVE_V2_SECURE = true
getgenv()._XASON_SESSION_ID = tostring(tick()) .. "_" .. tostring(math.random(1000000, 9999999))
getgenv()._XASON_USER_VERIFY = game.Players.LocalPlayer.UserId
getgenv()._XASON_CHECKSUM = string.len(MASTER_AUTH_KEY)

-- Create validation function that's hard to fake
getgenv()._XASON_VALIDATE = function()
    local env = getgenv()
    if not env._XASON_MASTER_AUTH_KEY_DO_NOT_TOUCH then return false end
    if not env._XASON_LOADER_ACTIVE_V2_SECURE then return false end
    if not env._XASON_SESSION_ID then return false end
    if env._XASON_USER_VERIFY ~= game.Players.LocalPlayer.UserId then return false end
    if env._XASON_CHECKSUM ~= string.len(env._XASON_MASTER_AUTH_KEY_DO_NOT_TOUCH) then return false end
    if not string.find(env._XASON_MASTER_AUTH_KEY_DO_NOT_TOUCH, "_USER_" .. game.Players.LocalPlayer.UserId) then return false end
    if not string.find(env._XASON_MASTER_AUTH_KEY_DO_NOT_TOUCH, "_JOB_" .. game.JobId) then return false end
    return true
end

-- Create hash of the auth key for extra validation
local function simpleHash(str)
    local hash = 0
    for i = 1, #str do
        hash = (hash + string.byte(str, i)) * 31
        hash = hash % 1000000007
    end
    return hash
end

getgenv()._XASON_HASH = simpleHash(MASTER_AUTH_KEY)

local gameId = game.PlaceId

-- Table of supported games with their script URLs
local supportedGames = {
    [6839171747] = "https://raw.githubusercontent.com/XasonYTB/ZeScript-Doors/refs/heads/main/Doors",
    -- Add more games here in the format:
    -- [PLACE_ID] = "SCRIPT_URL",
}

-- Function to load the script
local function loadScript(url)
    local success, result = pcall(function()
        local code = game:HttpGet(url)  -- Added HttpGet to fetch the code
        loadstring(code)()
    end)
    
    if not success then
        warn("Failed to load script: " .. tostring(result))
        game.StarterGui:SetCore("SendNotification", {
            Title = "Script Hub",
            Text = "Failed to load script!",
            Duration = 5
        })
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Script Hub",
            Text = "Script loaded successfully!",
            Duration = 3
        })
    end
end

-- Check if the current game has a script
if supportedGames[gameId] then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Script Hub",
        Text = "Loading script for this game...",
        Duration = 3
    })
    
    -- Load the appropriate script
    loadScript(supportedGames[gameId])
else
    -- Game not supported
    game.StarterGui:SetCore("SendNotification", {
        Title = "Script Hub",
        Text = "This game is not supported yet!",
        Duration = 5
    })
    
    print("Unsupported game. Place ID: " .. tostring(gameId))
end
